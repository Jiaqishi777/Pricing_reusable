# -*- coding: utf-8 -*-
"""MHR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H1RFF0J3x7qoYSE66P8AaCKKk0Nx-1Eu
"""

import numpy as np
import math
import scipy.stats as spst
from scipy.optimize import minimize
import scipy.stats as spst
import time

def coeff(C): # factorial
    w = [1]
    for k in range(1,C+1):
        w.append(w[k-1]*k)
    return w 

def in_stock(x,C,w): # service level
    term = 0
    for i in range(C):
        term += x**i/w[i]
    return term/(term + x**C/w[C])  

def Ratio(t,s,C,w): # compute revenu ratio R(s,t)
    x = C*t+s
    return (1+t)*in_stock(x,C,w)

def h3(w0,w2,w3,C,w):
   # h3 is the upper bound of s, i.e., the s2 function
    # w1 =w_C-1; w2=w_C-2; w3 = w_C-3; w:factorial
    term_1 = w0**(C-3)*w3/w[C-3] + w0**(C-3)*w3*w2/w[C-2]
    term_2 = 1 + w0**(C-3)*w3/w[C-2] + w0**(C-3)*w3*w2/w[C-1]
    for i in range(1,C-2):
        term_1 += w0**i/w[i-1]
        term_2 += w0**i/w[i]
    return term_1/term_2

def g3(w1,w2,w3,w0,C,w): 
    # g3 is the lower bound of t, i.e., the t2 function
    # w2=w_C-2; w3 = w_C-3; w: factorial 
    term = 1 + w0*w3**(C-3)*w2/w[C-1]
    for i in range(1,C-1):
        term += w3**(i-1)*w0/w[i]
    return w3**(C-3)*w2*w1*w0/w[C]/term  

def lower(w2,w3,w0,c):
    # the value of w_C-1
    # w2=w_C-2; w3 = w_C-3; 
    term1 = (c*(c-1)*w2+w2*w0)/(c*w2+c*(c-1))
    term2 = w3 + 2/c/(c-2)*w3*w0 - w2*w3/(c-2)
    return max(term1,term2)

for c in range(3,4):
    start_time = time.time()
    w = coeff(c)
    M = 500
    # creat small cubes
    w0_test = np.linspace(c-2.7,(c+3)*c,M)
    w2_test = np.linspace(2*(c-2.7)/c,(c+3)*c,M)
    test = [] # store worst-case instance
    sample = [] # store worst-case ratio
    for j in range(M-1):
    # given the range w0_test[j] and w0_test[j+1], find the ranges of w_C-2 and w_C-3
    # w0_test[j]/c*3 <= w_C-3 <= w0_test[j+1], w0_test[j]/c*2 <= w_C-2 <= w0_test[j+1]
        index1 = min(range(len(w2_test)), key=lambda i: abs(w2_test[i]-2*w0_test[j]/c)) # min value of w_C-2
        index2 = min(range(len(w2_test)), key=lambda i: abs(w2_test[i]-w0_test[j+1])) # max value of w_C-2 and w_C-3
        if w2_test[index1]>2*w0_test[j]/c:
            index1 += -1
        if w2_test[index2]<w0_test[j+1]:
            index2 += 1
        ## compute lower bound 
        sample1 = []
        test1 = []
        for k in range(index1,min(index2,M-1)): # range of w_C-2
              # upper bound of s in small cube k,l,j
              s = h3(w0_test[j+1],w2_test[k+1],w0_test[j+1],c,w)
              # lower bound of w_C-1 given w_C-3, w_C-2, w_0 
              w1 =  min(lower(w2_test[k],w0_test[j],w0_test[j],c),w2_test[k])
              # lower bound of t
              t_lower = g3(w1,w2_test[k],w0_test[j],w0_test[j],c,w)  
              sample1.append(Ratio(t_lower,s,c,w))
              test1.append((w1,w2_test[k],w0_test[j],w0_test[j+1],t_lower,s))   
        sample.append(np.min(sample1))  
        test.append(test1[np.argmin(sample1)])          
    print(np.min(sample),c,test[np.argmin(sample)],len(sample)) 
    print("--- %s seconds ---" % (time.time() - start_time))

for c in range(4,48):
    start_time = time.time()
    w = coeff(c)
    M = 500
    # creat small cubes
    w0_test = np.linspace(c-2.7,(c+3)*c,M)
    w2_test = np.linspace(2*(c-2.7)/c,(c+3)*c,M)
    w3_test = np.linspace(2*(c-2.7)/c,(c+3)*c,M)
    test = [] # store worst-case instance
    sample = [] # store worst-case ratio
    for j in range(M-1):
    # given the range w0_test[j] and w0_test[j+1], find the ranges of w_C-2 and w_C-3
    # w0_test[j]/c*3 <= w_C-3 <= w0_test[j+1], w0_test[j]/c*2 <= w_C-2 <= w0_test[j+1]
        index1 = min(range(len(w2_test)), key=lambda i: abs(w2_test[i]-2*w0_test[j]/c)) # min value of w_C-2
        index2 = min(range(len(w2_test)), key=lambda i: abs(w2_test[i]-w0_test[j+1])) # max value of w_C-2 and w_C-3
        index3 = min(range(len(w3_test)), key=lambda i: abs(w3_test[i]-3*w0_test[j]/c)) # min value of w_C-3
        if w3_test[index3]>3*w0_test[j]/c: 
            index3 += -1
        if w2_test[index1]>2*w0_test[j]/c:
            index1 += -1
        if w2_test[index2]<w0_test[j+1]:
            index2 += 1
        ## compute lower bound 
        sample1 = []
        test1 = []
        for k in range(index1,min(index2,M-1)): # range of w_C-2
            for l in range(max(k,index3),min(M-1,index2)): # range of w_C-3
                # upper bound of s in small cube k,l,j
                s = h3(w0_test[j+1],w2_test[k+1],w3_test[l+1],c,w)
                # lower bound of w_C-1 given w_C-3, w_C-2, w_0 
                w1 =  min(lower(w2_test[k],w3_test[l],w0_test[j],c),w2_test[k])
                # lower bound of t
                t_lower = g3(w1,w2_test[k],w3_test[l],w0_test[j],c,w)  
                sample1.append(Ratio(t_lower,s,c,w))
                test1.append((w1,w2_test[k],w3_test[l],w0_test[j],w0_test[j+1],t_lower,s))   
        sample.append(np.min(sample1))  
        test.append(test1[np.argmin(sample1)])          
    print(np.min(sample),c,test[np.argmin(sample)],len(sample)) 
    print("--- %s seconds ---" % (time.time() - start_time))